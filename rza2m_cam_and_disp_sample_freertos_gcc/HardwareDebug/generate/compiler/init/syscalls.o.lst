   1              		.cpu cortex-a9
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"syscalls.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.get_errno,"ax",%progbits
  17              		.align	2
  18              		.syntax unified
  19              		.arm
  20              		.fpu neon
  22              	get_errno:
  23              	.LFB2:
  24              		.file 1 "../generate/compiler/init/syscalls.c"
   1:../generate/compiler/init/syscalls.c **** /*******************************************************************************
   2:../generate/compiler/init/syscalls.c **** * DISCLAIMER
   3:../generate/compiler/init/syscalls.c **** * This software is supplied by Renesas Electronics Corporation and is only
   4:../generate/compiler/init/syscalls.c **** * intended for use with Renesas products. No other uses are authorized. This
   5:../generate/compiler/init/syscalls.c **** * software is owned by Renesas Electronics Corporation and is protected under
   6:../generate/compiler/init/syscalls.c **** * all applicable laws, including copyright laws.
   7:../generate/compiler/init/syscalls.c **** * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
   8:../generate/compiler/init/syscalls.c **** * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
   9:../generate/compiler/init/syscalls.c **** * LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
  10:../generate/compiler/init/syscalls.c **** * AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
  11:../generate/compiler/init/syscalls.c **** * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
  12:../generate/compiler/init/syscalls.c **** * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
  13:../generate/compiler/init/syscalls.c **** * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
  14:../generate/compiler/init/syscalls.c **** * ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
  15:../generate/compiler/init/syscalls.c **** * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
  16:../generate/compiler/init/syscalls.c **** * Renesas reserves the right, without notice, to make changes to this software
  17:../generate/compiler/init/syscalls.c **** * and to discontinue the availability of this software. By using this software,
  18:../generate/compiler/init/syscalls.c **** * you agree to the additional terms and conditions found by accessing the
  19:../generate/compiler/init/syscalls.c **** * following link:
  20:../generate/compiler/init/syscalls.c **** * http://www.renesas.com/disclaimer
  21:../generate/compiler/init/syscalls.c **** * Copyright (C) 2018 Renesas Electronics Corporation. All rights reserved.
  22:../generate/compiler/init/syscalls.c **** *******************************************************************************/
  23:../generate/compiler/init/syscalls.c **** /*******************************************************************************
  24:../generate/compiler/init/syscalls.c **** * File Name : syscalls.c
  25:../generate/compiler/init/syscalls.c **** * Description :
  26:../generate/compiler/init/syscalls.c **** ******************************************************************************/
  27:../generate/compiler/init/syscalls.c **** /* Copyright (C) 2010 Embecosm Limited
  28:../generate/compiler/init/syscalls.c ****  * Creative Commons License The document entitled "Howto: Porting newlib"
  29:../generate/compiler/init/syscalls.c ****  * by Jeremy Bennett of Embecosm is licensed under a Creative Commons
  30:../generate/compiler/init/syscalls.c ****  * Attribution 2.0 UK: England & Wales License. See the Legal Notice for details. 
  31:../generate/compiler/init/syscalls.c ****  */
  32:../generate/compiler/init/syscalls.c **** #include <sys/stat.h>
  33:../generate/compiler/init/syscalls.c **** #include <errno.h>
  34:../generate/compiler/init/syscalls.c **** #include <r_devlink_wrapper.h>
  35:../generate/compiler/init/syscalls.c **** #include <unistd.h>
  36:../generate/compiler/init/syscalls.c **** 
  37:../generate/compiler/init/syscalls.c **** #include "swi.h"
  38:../generate/compiler/init/syscalls.c **** #include "r_typedefs.h"
  39:../generate/compiler/init/syscalls.c **** #include "r_startup_config.h"
  40:../generate/compiler/init/syscalls.c **** 
  41:../generate/compiler/init/syscalls.c **** #undef errno
  42:../generate/compiler/init/syscalls.c **** extern int  errno;
  43:../generate/compiler/init/syscalls.c **** 
  44:../generate/compiler/init/syscalls.c **** 
  45:../generate/compiler/init/syscalls.c **** static int monitor_stdin;
  46:../generate/compiler/init/syscalls.c **** static int monitor_stdout;
  47:../generate/compiler/init/syscalls.c **** static int monitor_stderr;
  48:../generate/compiler/init/syscalls.c **** 
  49:../generate/compiler/init/syscalls.c **** /* Struct used to keep track of the file position, just so we
  50:../generate/compiler/init/syscalls.c ****    can implement fseek(fh,x,SEEK_CUR).  */
  51:../generate/compiler/init/syscalls.c **** 
  52:../generate/compiler/init/syscalls.c **** typedef struct
  53:../generate/compiler/init/syscalls.c **** {
  54:../generate/compiler/init/syscalls.c ****   int handle;
  55:../generate/compiler/init/syscalls.c ****   int pos;
  56:../generate/compiler/init/syscalls.c **** }
  57:../generate/compiler/init/syscalls.c **** poslog;
  58:../generate/compiler/init/syscalls.c **** 
  59:../generate/compiler/init/syscalls.c **** #define MAX_OPEN_FILES (20)
  60:../generate/compiler/init/syscalls.c **** 
  61:../generate/compiler/init/syscalls.c **** 
  62:../generate/compiler/init/syscalls.c **** /* Struct used to keep track of the file position, just so we
  63:../generate/compiler/init/syscalls.c ****    can implement fseek(fh,x,SEEK_CUR).  */
  64:../generate/compiler/init/syscalls.c **** struct fdent
  65:../generate/compiler/init/syscalls.c **** {
  66:../generate/compiler/init/syscalls.c ****   int handle;
  67:../generate/compiler/init/syscalls.c ****   int pos;
  68:../generate/compiler/init/syscalls.c ****   int ipending; /* Indicates fdent is being used but 'handle' not yet
  69:../generate/compiler/init/syscalls.c ****                    allocated by the low level open  function */
  70:../generate/compiler/init/syscalls.c **** };
  71:../generate/compiler/init/syscalls.c **** 
  72:../generate/compiler/init/syscalls.c **** /* Forward prototypes.  */
  73:../generate/compiler/init/syscalls.c **** void    initialise_monitor_handles _PARAMS ((void));
  74:../generate/compiler/init/syscalls.c **** 
  75:../generate/compiler/init/syscalls.c **** static int get_errno (void);
  76:../generate/compiler/init/syscalls.c **** static int error (int result);
  77:../generate/compiler/init/syscalls.c **** static int wrap  _PARAMS ((int));
  78:../generate/compiler/init/syscalls.c **** 
  79:../generate/compiler/init/syscalls.c **** int _swiopen (const char * path, int flags);
  80:../generate/compiler/init/syscalls.c **** int _open (const char * path, int flags, ...);
  81:../generate/compiler/init/syscalls.c **** int _swiclose (int fh);
  82:../generate/compiler/init/syscalls.c **** int _close(int fh);
  83:../generate/compiler/init/syscalls.c **** int _swiwrite (int fh, char * ptr, int len);
  84:../generate/compiler/init/syscalls.c **** int _write(int fh , const char *buffer , unsigned int n);
  85:../generate/compiler/init/syscalls.c **** int _swiread (int fh, char * ptr, int len);
  86:../generate/compiler/init/syscalls.c **** int _read(int fh , char *buffer , unsigned int n);
  87:../generate/compiler/init/syscalls.c **** int _stat (const char *fname, struct stat *st);
  88:../generate/compiler/init/syscalls.c **** int _fstat (int fd, struct stat * st);
  89:../generate/compiler/init/syscalls.c **** int _getpid(int n);
  90:../generate/compiler/init/syscalls.c **** int _isatty(int fd);
  91:../generate/compiler/init/syscalls.c **** int _lseek (int fd, int ptr, int dir);
  92:../generate/compiler/init/syscalls.c **** caddr_t _sbrk (int incr);
  93:../generate/compiler/init/syscalls.c **** 
  94:../generate/compiler/init/syscalls.c **** extern int starc_write(int fh , const char *buffer , unsigned int n);
  95:../generate/compiler/init/syscalls.c **** extern int starc_read(int fh , char *buffer , unsigned int n);
  96:../generate/compiler/init/syscalls.c **** 
  97:../generate/compiler/init/syscalls.c **** void initialise_monitor_handles (void)
  98:../generate/compiler/init/syscalls.c **** {
  99:../generate/compiler/init/syscalls.c ****   /* Open the standard file descriptors by opening the special
 100:../generate/compiler/init/syscalls.c ****    * teletype device, ":tt", read-only to obtain a descritpor for
 101:../generate/compiler/init/syscalls.c ****    * standard input and write-only to obtain a descriptor for standard
 102:../generate/compiler/init/syscalls.c ****    * output. Finally, open ":tt" in append mode to obtain a descriptor
 103:../generate/compiler/init/syscalls.c ****    * for standard error. Since this is a write mode, most kernels will
 104:../generate/compiler/init/syscalls.c ****    * probably return the same value as for standard output, but the
 105:../generate/compiler/init/syscalls.c ****    * kernel can differentiate the two using the mode flag and return a
 106:../generate/compiler/init/syscalls.c ****    * different descriptor for standard error.
 107:../generate/compiler/init/syscalls.c ****    */
 108:../generate/compiler/init/syscalls.c **** 
 109:../generate/compiler/init/syscalls.c ****   int fh;
 110:../generate/compiler/init/syscalls.c ****   char * name;
 111:../generate/compiler/init/syscalls.c ****   name = "\\\\.\\stdin";
 112:../generate/compiler/init/syscalls.c ****   fh = low_open(name, O_RDWR);
 113:../generate/compiler/init/syscalls.c ****   monitor_stdin = fh;
 114:../generate/compiler/init/syscalls.c ****   name = "\\\\.\\stdout";
 115:../generate/compiler/init/syscalls.c ****   fh = low_open(name, O_WRONLY);
 116:../generate/compiler/init/syscalls.c ****   monitor_stdout = fh;
 117:../generate/compiler/init/syscalls.c ****   name = "\\\\.\\stderr";
 118:../generate/compiler/init/syscalls.c ****   fh = low_open(name, O_WRONLY);
 119:../generate/compiler/init/syscalls.c **** 
 120:../generate/compiler/init/syscalls.c ****   /* If we failed to open stderr, redirect to stdout. */
 121:../generate/compiler/init/syscalls.c ****   if (monitor_stderr == -1)
 122:../generate/compiler/init/syscalls.c ****   {
 123:../generate/compiler/init/syscalls.c ****       monitor_stderr = monitor_stdout;
 124:../generate/compiler/init/syscalls.c ****   }
 125:../generate/compiler/init/syscalls.c **** }
 126:../generate/compiler/init/syscalls.c **** 
 127:../generate/compiler/init/syscalls.c **** static int get_errno (void)
 128:../generate/compiler/init/syscalls.c **** {
  25              		.loc 1 128 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
 129:../generate/compiler/init/syscalls.c **** #if SWI_TRAP_ENABLED
 130:../generate/compiler/init/syscalls.c ****   __asm ("swi %a0" :: "i" (SWI_GetErrno));
 131:../generate/compiler/init/syscalls.c **** #endif
 132:../generate/compiler/init/syscalls.c ****   return 0;
 133:../generate/compiler/init/syscalls.c **** }
  30              		.loc 1 133 0
  31 0000 0000A0E3 		mov	r0, #0
  32 0004 1EFF2FE1 		bx	lr
  33              		.cfi_endproc
  34              	.LFE2:
  36              		.section	.text.error,"ax",%progbits
  37              		.align	2
  38              		.syntax unified
  39              		.arm
  40              		.fpu neon
  42              	error:
  43              	.LFB3:
 134:../generate/compiler/init/syscalls.c **** 
 135:../generate/compiler/init/syscalls.c **** static int error (int result)
 136:../generate/compiler/init/syscalls.c **** {
  44              		.loc 1 136 0
  45              		.cfi_startproc
  46              		@ args = 0, pretend = 0, frame = 0
  47              		@ frame_needed = 0, uses_anonymous_args = 0
  48              	.LVL0:
  49 0000 10402DE9 		push	{r4, lr}
  50              		.cfi_def_cfa_offset 8
  51              		.cfi_offset 4, -8
  52              		.cfi_offset 14, -4
  53 0004 0040A0E1 		mov	r4, r0
 137:../generate/compiler/init/syscalls.c ****   errno = get_errno ();
  54              		.loc 1 137 0
  55 0008 FEFFFFEB 		bl	get_errno
  56              	.LVL1:
  57 000c 003000E3 		movw	r3, #:lower16:errno
  58 0010 003040E3 		movt	r3, #:upper16:errno
  59 0014 000083E5 		str	r0, [r3]
 138:../generate/compiler/init/syscalls.c ****   return result;
 139:../generate/compiler/init/syscalls.c **** }
  60              		.loc 1 139 0
  61 0018 0400A0E1 		mov	r0, r4
  62 001c 1080BDE8 		pop	{r4, pc}
  63              		.cfi_endproc
  64              	.LFE3:
  66              		.section	.text.wrap,"ax",%progbits
  67              		.align	2
  68              		.syntax unified
  69              		.arm
  70              		.fpu neon
  72              	wrap:
  73              	.LFB4:
 140:../generate/compiler/init/syscalls.c **** 
 141:../generate/compiler/init/syscalls.c **** 
 142:../generate/compiler/init/syscalls.c **** static int wrap (int result)
 143:../generate/compiler/init/syscalls.c **** {
  74              		.loc 1 143 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              	.LVL2:
 144:../generate/compiler/init/syscalls.c ****   if (result == -1)
  79              		.loc 1 144 0
  80 0000 010070E3 		cmn	r0, #1
  81 0004 1EFF2F11 		bxne	lr
 143:../generate/compiler/init/syscalls.c ****   if (result == -1)
  82              		.loc 1 143 0
  83 0008 10402DE9 		push	{r4, lr}
  84              		.cfi_def_cfa_offset 8
  85              		.cfi_offset 4, -8
  86              		.cfi_offset 14, -4
 145:../generate/compiler/init/syscalls.c ****   {
 146:../generate/compiler/init/syscalls.c ****     return error (-1);
  87              		.loc 1 146 0
  88 000c FEFFFFEB 		bl	error
  89              	.LVL3:
 147:../generate/compiler/init/syscalls.c ****   }
 148:../generate/compiler/init/syscalls.c ****   return result;
 149:../generate/compiler/init/syscalls.c **** }
  90              		.loc 1 149 0
  91 0010 1080BDE8 		pop	{r4, pc}
  92              		.cfi_endproc
  93              	.LFE4:
  95              		.section	.text.initialise_monitor_handles,"ax",%progbits
  96              		.align	2
  97              		.global	initialise_monitor_handles
  98              		.syntax unified
  99              		.arm
 100              		.fpu neon
 102              	initialise_monitor_handles:
 103              	.LFB1:
  98:../generate/compiler/init/syscalls.c ****   /* Open the standard file descriptors by opening the special
 104              		.loc 1 98 0
 105              		.cfi_startproc
 106              		@ args = 0, pretend = 0, frame = 0
 107              		@ frame_needed = 0, uses_anonymous_args = 0
 108 0000 10402DE9 		push	{r4, lr}
 109              		.cfi_def_cfa_offset 8
 110              		.cfi_offset 4, -8
 111              		.cfi_offset 14, -4
 112              	.LVL4:
 112:../generate/compiler/init/syscalls.c ****   monitor_stdin = fh;
 113              		.loc 1 112 0
 114 0004 0210A0E3 		mov	r1, #2
 115 0008 000000E3 		movw	r0, #:lower16:.LC0
 116 000c 000040E3 		movt	r0, #:upper16:.LC0
 117 0010 FEFFFFEB 		bl	low_open
 118              	.LVL5:
 115:../generate/compiler/init/syscalls.c ****   monitor_stdout = fh;
 119              		.loc 1 115 0
 120 0014 0110A0E3 		mov	r1, #1
 121 0018 000000E3 		movw	r0, #:lower16:.LC1
 122 001c 000040E3 		movt	r0, #:upper16:.LC1
 123 0020 FEFFFFEB 		bl	low_open
 124              	.LVL6:
 116:../generate/compiler/init/syscalls.c ****   name = "\\\\.\\stderr";
 125              		.loc 1 116 0
 126 0024 003000E3 		movw	r3, #:lower16:.LANCHOR0
 127 0028 003040E3 		movt	r3, #:upper16:.LANCHOR0
 128 002c 000083E5 		str	r0, [r3]
 129              	.LVL7:
 118:../generate/compiler/init/syscalls.c **** 
 130              		.loc 1 118 0
 131 0030 0110A0E3 		mov	r1, #1
 132 0034 000000E3 		movw	r0, #:lower16:.LC2
 133              	.LVL8:
 134 0038 000040E3 		movt	r0, #:upper16:.LC2
 135 003c FEFFFFEB 		bl	low_open
 136              	.LVL9:
 121:../generate/compiler/init/syscalls.c ****   {
 137              		.loc 1 121 0
 138 0040 003000E3 		movw	r3, #:lower16:.LANCHOR1
 139 0044 003040E3 		movt	r3, #:upper16:.LANCHOR1
 140 0048 003093E5 		ldr	r3, [r3]
 141 004c 010073E3 		cmn	r3, #1
 142 0050 1080BD18 		popne	{r4, pc}
 123:../generate/compiler/init/syscalls.c ****   }
 143              		.loc 1 123 0
 144 0054 003000E3 		movw	r3, #:lower16:.LANCHOR1
 145 0058 003040E3 		movt	r3, #:upper16:.LANCHOR1
 146 005c 002000E3 		movw	r2, #:lower16:.LANCHOR0
 147 0060 002040E3 		movt	r2, #:upper16:.LANCHOR0
 148 0064 002092E5 		ldr	r2, [r2]
 149 0068 002083E5 		str	r2, [r3]
 150 006c 1080BDE8 		pop	{r4, pc}
 151              		.cfi_endproc
 152              	.LFE1:
 154              		.section	.text._getpid,"ax",%progbits
 155              		.align	2
 156              		.global	_getpid
 157              		.syntax unified
 158              		.arm
 159              		.fpu neon
 161              	_getpid:
 162              	.LFB5:
 150:../generate/compiler/init/syscalls.c **** 
 151:../generate/compiler/init/syscalls.c **** /********************************************************/
 152:../generate/compiler/init/syscalls.c **** int _getpid(int n)
 153:../generate/compiler/init/syscalls.c **** {
 163              		.loc 1 153 0
 164              		.cfi_startproc
 165              		@ args = 0, pretend = 0, frame = 0
 166              		@ frame_needed = 0, uses_anonymous_args = 0
 167              		@ link register save eliminated.
 168              	.LVL10:
 154:../generate/compiler/init/syscalls.c ****   UNUSED_PARAM(n);
 155:../generate/compiler/init/syscalls.c **** 
 156:../generate/compiler/init/syscalls.c ****   return  1;
 157:../generate/compiler/init/syscalls.c **** }
 169              		.loc 1 157 0
 170 0000 0100A0E3 		mov	r0, #1
 171              	.LVL11:
 172 0004 1EFF2FE1 		bx	lr
 173              		.cfi_endproc
 174              	.LFE5:
 176              		.section	.text._lseek,"ax",%progbits
 177              		.align	2
 178              		.global	_lseek
 179              		.syntax unified
 180              		.arm
 181              		.fpu neon
 183              	_lseek:
 184              	.LFB7:
 158:../generate/compiler/init/syscalls.c **** 
 159:../generate/compiler/init/syscalls.c **** /*******************************************************************************
 160:../generate/compiler/init/syscalls.c **** * Function Name: _sbrk
 161:../generate/compiler/init/syscalls.c **** * Description  : 
 162:../generate/compiler/init/syscalls.c **** * Arguments    : incr - Requested memory size.  
 163:../generate/compiler/init/syscalls.c **** * Return Value : Extended address of heap tail.
 164:../generate/compiler/init/syscalls.c **** *******************************************************************************/
 165:../generate/compiler/init/syscalls.c **** caddr_t _sbrk (int incr)
 166:../generate/compiler/init/syscalls.c ****     {
 167:../generate/compiler/init/syscalls.c ****   extern char   end __asm ("__heap_start");         /* Defined by the linker.  */
 168:../generate/compiler/init/syscalls.c ****   extern char   heap_limit __asm ("__heap_end");    /* Defined by the linker.  */
 169:../generate/compiler/init/syscalls.c ****   static char * heap_end = NULL;
 170:../generate/compiler/init/syscalls.c ****   char *        prev_heap_end;
 171:../generate/compiler/init/syscalls.c **** 
 172:../generate/compiler/init/syscalls.c ****   if (heap_end == NULL)
 173:../generate/compiler/init/syscalls.c ****     heap_end = & end;
 174:../generate/compiler/init/syscalls.c **** 
 175:../generate/compiler/init/syscalls.c ****   prev_heap_end = heap_end;
 176:../generate/compiler/init/syscalls.c **** 
 177:../generate/compiler/init/syscalls.c ****   if (heap_end + incr > &heap_limit)
 178:../generate/compiler/init/syscalls.c ****     {
 179:../generate/compiler/init/syscalls.c ****       /* Some of the libstdc++-v3 tests rely upon detecting
 180:../generate/compiler/init/syscalls.c ****      out of memory errors, so do not abort here.  */
 181:../generate/compiler/init/syscalls.c **** 
 182:../generate/compiler/init/syscalls.c **** 	    _write (1, "_sbrk: Heap and stack collision\n", 32);
 183:../generate/compiler/init/syscalls.c **** 
 184:../generate/compiler/init/syscalls.c **** #if 0
 185:../generate/compiler/init/syscalls.c ****       extern void abort (void);
 186:../generate/compiler/init/syscalls.c **** 
 187:../generate/compiler/init/syscalls.c ****       _write (1, "_sbrk: Heap and stack collision\n", 32);
 188:../generate/compiler/init/syscalls.c **** 
 189:../generate/compiler/init/syscalls.c ****       abort ();
 190:../generate/compiler/init/syscalls.c **** #else
 191:../generate/compiler/init/syscalls.c ****       errno = ENOMEM;
 192:../generate/compiler/init/syscalls.c ****       return (caddr_t) -1;
 193:../generate/compiler/init/syscalls.c **** #endif
 194:../generate/compiler/init/syscalls.c ****     }
 195:../generate/compiler/init/syscalls.c **** 
 196:../generate/compiler/init/syscalls.c ****   heap_end += incr;
 197:../generate/compiler/init/syscalls.c **** 
 198:../generate/compiler/init/syscalls.c ****   return (caddr_t) prev_heap_end;
 199:../generate/compiler/init/syscalls.c **** }
 200:../generate/compiler/init/syscalls.c **** /*******************************************************************************
 201:../generate/compiler/init/syscalls.c **** End of function _sbrk
 202:../generate/compiler/init/syscalls.c **** *******************************************************************************/
 203:../generate/compiler/init/syscalls.c **** 
 204:../generate/compiler/init/syscalls.c **** /********************************************************/
 205:../generate/compiler/init/syscalls.c **** int _lseek (int fd, int ptr, int dir)
 206:../generate/compiler/init/syscalls.c **** {
 185              		.loc 1 206 0
 186              		.cfi_startproc
 187              		@ args = 0, pretend = 0, frame = 0
 188              		@ frame_needed = 0, uses_anonymous_args = 0
 189              		@ link register save eliminated.
 190              	.LVL12:
 207:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(fd);
 208:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(ptr);
 209:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(dir);
 210:../generate/compiler/init/syscalls.c **** 
 211:../generate/compiler/init/syscalls.c ****     return  0;
 212:../generate/compiler/init/syscalls.c **** }
 191              		.loc 1 212 0
 192 0000 0000A0E3 		mov	r0, #0
 193              	.LVL13:
 194 0004 1EFF2FE1 		bx	lr
 195              		.cfi_endproc
 196              	.LFE7:
 198              		.section	.text._swiread,"ax",%progbits
 199              		.align	2
 200              		.global	_swiread
 201              		.syntax unified
 202              		.arm
 203              		.fpu neon
 205              	_swiread:
 206              	.LFB8:
 213:../generate/compiler/init/syscalls.c **** 
 214:../generate/compiler/init/syscalls.c **** 
 215:../generate/compiler/init/syscalls.c **** /* Returns # chars not! written.  */
 216:../generate/compiler/init/syscalls.c **** int _swiread (int fh, char * ptr, int len)
 217:../generate/compiler/init/syscalls.c **** {
 207              		.loc 1 217 0
 208              		.cfi_startproc
 209              		@ args = 0, pretend = 0, frame = 0
 210              		@ frame_needed = 0, uses_anonymous_args = 0
 211              	.LVL14:
 212 0000 10402DE9 		push	{r4, lr}
 213              		.cfi_def_cfa_offset 8
 214              		.cfi_offset 4, -8
 215              		.cfi_offset 14, -4
 218:../generate/compiler/init/syscalls.c ****   int_t   i = low_read(fh, (uint8_t*)ptr, (uint32_t)len);
 216              		.loc 1 218 0
 217 0004 FEFFFFEB 		bl	low_read
 218              	.LVL15:
 219:../generate/compiler/init/syscalls.c ****   return wrap(i);
 219              		.loc 1 219 0
 220 0008 FEFFFFEB 		bl	wrap
 221              	.LVL16:
 220:../generate/compiler/init/syscalls.c **** }
 222              		.loc 1 220 0
 223 000c 1080BDE8 		pop	{r4, pc}
 224              		.cfi_endproc
 225              	.LFE8:
 227              		.section	.text._swiclose,"ax",%progbits
 228              		.align	2
 229              		.global	_swiclose
 230              		.syntax unified
 231              		.arm
 232              		.fpu neon
 234              	_swiclose:
 235              	.LFB11:
 221:../generate/compiler/init/syscalls.c **** 
 222:../generate/compiler/init/syscalls.c **** 
 223:../generate/compiler/init/syscalls.c **** int _swiopen (const char * path, int flags)
 224:../generate/compiler/init/syscalls.c **** {
 225:../generate/compiler/init/syscalls.c ****   int aflags = 0, fh;
 226:../generate/compiler/init/syscalls.c **** 
 227:../generate/compiler/init/syscalls.c ****   /* It is an error to open a file that already exists. */
 228:../generate/compiler/init/syscalls.c ****   if ((flags & O_CREAT)
 229:../generate/compiler/init/syscalls.c ****       && (flags & O_EXCL))
 230:../generate/compiler/init/syscalls.c ****     {
 231:../generate/compiler/init/syscalls.c ****       struct stat st;
 232:../generate/compiler/init/syscalls.c ****       int res;
 233:../generate/compiler/init/syscalls.c ****       res = _stat (path, &st);
 234:../generate/compiler/init/syscalls.c ****       if (res != -1)
 235:../generate/compiler/init/syscalls.c ****       {
 236:../generate/compiler/init/syscalls.c ****          errno = EEXIST;
 237:../generate/compiler/init/syscalls.c ****          return -1;
 238:../generate/compiler/init/syscalls.c ****       }
 239:../generate/compiler/init/syscalls.c ****     }
 240:../generate/compiler/init/syscalls.c **** 
 241:../generate/compiler/init/syscalls.c ****   /* The flags are Unix-style, so we need to convert them. */
 242:../generate/compiler/init/syscalls.c **** #ifdef O_BINARY
 243:../generate/compiler/init/syscalls.c ****   if (flags & O_BINARY)
 244:../generate/compiler/init/syscalls.c ****     aflags |= 1;
 245:../generate/compiler/init/syscalls.c **** #endif
 246:../generate/compiler/init/syscalls.c **** 
 247:../generate/compiler/init/syscalls.c ****   /* In O_RDONLY we expect aflags == 0. */
 248:../generate/compiler/init/syscalls.c ****   if (flags & O_RDWR) {
 249:../generate/compiler/init/syscalls.c ****     aflags |= O_RDWR;
 250:../generate/compiler/init/syscalls.c ****   }
 251:../generate/compiler/init/syscalls.c ****   if (flags & O_WRONLY) {
 252:../generate/compiler/init/syscalls.c ****     aflags |= O_WRONLY;
 253:../generate/compiler/init/syscalls.c ****   }
 254:../generate/compiler/init/syscalls.c ****   if (flags & O_CREAT){
 255:../generate/compiler/init/syscalls.c ****     aflags |= O_CREAT;
 256:../generate/compiler/init/syscalls.c ****   }
 257:../generate/compiler/init/syscalls.c ****   if (flags & O_TRUNC){
 258:../generate/compiler/init/syscalls.c ****     aflags |= O_TRUNC;
 259:../generate/compiler/init/syscalls.c ****   }
 260:../generate/compiler/init/syscalls.c ****   if (flags & O_WRONLY){
 261:../generate/compiler/init/syscalls.c ****     aflags |= O_WRONLY;
 262:../generate/compiler/init/syscalls.c ****   }
 263:../generate/compiler/init/syscalls.c ****   if (flags & O_APPEND){
 264:../generate/compiler/init/syscalls.c ****     aflags |= O_APPEND;
 265:../generate/compiler/init/syscalls.c ****   }
 266:../generate/compiler/init/syscalls.c **** 
 267:../generate/compiler/init/syscalls.c ****     fh = low_open((char *)path, aflags);
 268:../generate/compiler/init/syscalls.c **** 
 269:../generate/compiler/init/syscalls.c ****     /* Return a user file descriptor or an error. */
 270:../generate/compiler/init/syscalls.c ****     if (fh >= 0)
 271:../generate/compiler/init/syscalls.c ****     {
 272:../generate/compiler/init/syscalls.c ****       return (fh);
 273:../generate/compiler/init/syscalls.c ****     }
 274:../generate/compiler/init/syscalls.c ****     errno = EEXIST;
 275:../generate/compiler/init/syscalls.c ****     return (-1);
 276:../generate/compiler/init/syscalls.c **** }
 277:../generate/compiler/init/syscalls.c **** 
 278:../generate/compiler/init/syscalls.c **** 
 279:../generate/compiler/init/syscalls.c **** int _open (const char * path, int flags, ...)
 280:../generate/compiler/init/syscalls.c **** {
 281:../generate/compiler/init/syscalls.c ****   return wrap (_swiopen (path, flags));
 282:../generate/compiler/init/syscalls.c **** }
 283:../generate/compiler/init/syscalls.c **** 
 284:../generate/compiler/init/syscalls.c **** /* fh, is a valid internal file handle. */
 285:../generate/compiler/init/syscalls.c **** int _swiclose (int fh)
 286:../generate/compiler/init/syscalls.c **** {
 236              		.loc 1 286 0
 237              		.cfi_startproc
 238              		@ args = 0, pretend = 0, frame = 0
 239              		@ frame_needed = 0, uses_anonymous_args = 0
 240              	.LVL17:
 241 0000 10402DE9 		push	{r4, lr}
 242              		.cfi_def_cfa_offset 8
 243              		.cfi_offset 4, -8
 244              		.cfi_offset 14, -4
 287:../generate/compiler/init/syscalls.c ****   int   res = low_close(fh);
 245              		.loc 1 287 0
 246 0004 FEFFFFEB 		bl	low_close
 247              	.LVL18:
 288:../generate/compiler/init/syscalls.c ****   return res;
 289:../generate/compiler/init/syscalls.c **** }
 248              		.loc 1 289 0
 249 0008 1080BDE8 		pop	{r4, pc}
 250              		.cfi_endproc
 251              	.LFE11:
 253              		.section	.text._close,"ax",%progbits
 254              		.align	2
 255              		.global	_close
 256              		.syntax unified
 257              		.arm
 258              		.fpu neon
 260              	_close:
 261              	.LFB12:
 290:../generate/compiler/init/syscalls.c **** 
 291:../generate/compiler/init/syscalls.c **** 
 292:../generate/compiler/init/syscalls.c **** /********************************************************/
 293:../generate/compiler/init/syscalls.c **** int _close(int fh)
 294:../generate/compiler/init/syscalls.c **** {
 262              		.loc 1 294 0
 263              		.cfi_startproc
 264              		@ args = 0, pretend = 0, frame = 0
 265              		@ frame_needed = 0, uses_anonymous_args = 0
 266              	.LVL19:
 267 0000 10402DE9 		push	{r4, lr}
 268              		.cfi_def_cfa_offset 8
 269              		.cfi_offset 4, -8
 270              		.cfi_offset 14, -4
 295:../generate/compiler/init/syscalls.c ****     errno = EBADF;
 271              		.loc 1 295 0
 272 0004 004000E3 		movw	r4, #:lower16:errno
 273 0008 004040E3 		movt	r4, #:upper16:errno
 274 000c 0930A0E3 		mov	r3, #9
 275 0010 003084E5 		str	r3, [r4]
 296:../generate/compiler/init/syscalls.c **** 
 297:../generate/compiler/init/syscalls.c ****     /* Attempt to close the handle. */
 298:../generate/compiler/init/syscalls.c ****     errno = _swiclose (fh);
 276              		.loc 1 298 0
 277 0014 FEFFFFEB 		bl	_swiclose
 278              	.LVL20:
 279 0018 000084E5 		str	r0, [r4]
 299:../generate/compiler/init/syscalls.c ****     return wrap (errno);
 280              		.loc 1 299 0
 281 001c FEFFFFEB 		bl	wrap
 282              	.LVL21:
 300:../generate/compiler/init/syscalls.c **** }
 283              		.loc 1 300 0
 284 0020 1080BDE8 		pop	{r4, pc}
 285              		.cfi_endproc
 286              	.LFE12:
 288              		.section	.text._read,"ax",%progbits
 289              		.align	2
 290              		.global	_read
 291              		.syntax unified
 292              		.arm
 293              		.fpu neon
 295              	_read:
 296              	.LFB13:
 301:../generate/compiler/init/syscalls.c **** 
 302:../generate/compiler/init/syscalls.c **** /******************************************************************************
 303:../generate/compiler/init/syscalls.c **** * Function Name: _read
 304:../generate/compiler/init/syscalls.c **** * Description  : GNU interface to low-level I/O read
 305:../generate/compiler/init/syscalls.c **** * Arguments    : int file_no
 306:../generate/compiler/init/syscalls.c **** *              : const char *buffer
 307:../generate/compiler/init/syscalls.c **** *              : unsigned int n
 308:../generate/compiler/init/syscalls.c **** * Return Value : none
 309:../generate/compiler/init/syscalls.c **** ******************************************************************************/
 310:../generate/compiler/init/syscalls.c **** int _read(int fh , char *buffer , unsigned int n)
 311:../generate/compiler/init/syscalls.c **** {
 297              		.loc 1 311 0
 298              		.cfi_startproc
 299              		@ args = 0, pretend = 0, frame = 0
 300              		@ frame_needed = 0, uses_anonymous_args = 0
 301              	.LVL22:
 302 0000 10402DE9 		push	{r4, lr}
 303              		.cfi_def_cfa_offset 8
 304              		.cfi_offset 4, -8
 305              		.cfi_offset 14, -4
 312:../generate/compiler/init/syscalls.c ****       int   iResult = low_read(fh, (uint8_t*) buffer, (uint32_t) n);
 306              		.loc 1 312 0
 307 0004 FEFFFFEB 		bl	low_read
 308              	.LVL23:
 313:../generate/compiler/init/syscalls.c ****       return wrap(iResult);
 309              		.loc 1 313 0
 310 0008 FEFFFFEB 		bl	wrap
 311              	.LVL24:
 314:../generate/compiler/init/syscalls.c **** }
 312              		.loc 1 314 0
 313 000c 1080BDE8 		pop	{r4, pc}
 314              		.cfi_endproc
 315              	.LFE13:
 317              		.section	.text._swiwrite,"ax",%progbits
 318              		.align	2
 319              		.global	_swiwrite
 320              		.syntax unified
 321              		.arm
 322              		.fpu neon
 324              	_swiwrite:
 325              	.LFB14:
 315:../generate/compiler/init/syscalls.c **** 
 316:../generate/compiler/init/syscalls.c **** 
 317:../generate/compiler/init/syscalls.c **** /* fh, is a valid internal file handle.
 318:../generate/compiler/init/syscalls.c ****    Returns the number of bytes *not* written. */
 319:../generate/compiler/init/syscalls.c **** int _swiwrite (int fh, char * ptr, int len)
 320:../generate/compiler/init/syscalls.c **** {
 326              		.loc 1 320 0
 327              		.cfi_startproc
 328              		@ args = 0, pretend = 0, frame = 0
 329              		@ frame_needed = 0, uses_anonymous_args = 0
 330              	.LVL25:
 331 0000 10402DE9 		push	{r4, lr}
 332              		.cfi_def_cfa_offset 8
 333              		.cfi_offset 4, -8
 334              		.cfi_offset 14, -4
 321:../generate/compiler/init/syscalls.c ****   int_t i;
 322:../generate/compiler/init/syscalls.c **** 
 323:../generate/compiler/init/syscalls.c ****   i = low_write(fh, (uint8_t*)ptr, (uint32_t)len);
 335              		.loc 1 323 0
 336 0004 FEFFFFEB 		bl	low_write
 337              	.LVL26:
 324:../generate/compiler/init/syscalls.c **** 
 325:../generate/compiler/init/syscalls.c ****   return wrap(i);
 338              		.loc 1 325 0
 339 0008 FEFFFFEB 		bl	wrap
 340              	.LVL27:
 326:../generate/compiler/init/syscalls.c **** }
 341              		.loc 1 326 0
 342 000c 1080BDE8 		pop	{r4, pc}
 343              		.cfi_endproc
 344              	.LFE14:
 346              		.section	.text._write,"ax",%progbits
 347              		.align	2
 348              		.global	_write
 349              		.syntax unified
 350              		.arm
 351              		.fpu neon
 353              	_write:
 354              	.LFB15:
 327:../generate/compiler/init/syscalls.c **** 
 328:../generate/compiler/init/syscalls.c **** /******************************************************************************
 329:../generate/compiler/init/syscalls.c **** * Function Name: _write
 330:../generate/compiler/init/syscalls.c **** * Description  : GNU interface to low-level I/O write
 331:../generate/compiler/init/syscalls.c **** * Arguments    : int file_no
 332:../generate/compiler/init/syscalls.c **** *              : const char *buffer
 333:../generate/compiler/init/syscalls.c **** *              : unsigned int n
 334:../generate/compiler/init/syscalls.c **** * Return Value : none
 335:../generate/compiler/init/syscalls.c **** ******************************************************************************/
 336:../generate/compiler/init/syscalls.c **** int _write(int fh , const char *buffer , unsigned int n)
 337:../generate/compiler/init/syscalls.c **** {
 355              		.loc 1 337 0
 356              		.cfi_startproc
 357              		@ args = 0, pretend = 0, frame = 0
 358              		@ frame_needed = 0, uses_anonymous_args = 0
 359              	.LVL28:
 360 0000 10402DE9 		push	{r4, lr}
 361              		.cfi_def_cfa_offset 8
 362              		.cfi_offset 4, -8
 363              		.cfi_offset 14, -4
 338:../generate/compiler/init/syscalls.c ****     int_t i;
 339:../generate/compiler/init/syscalls.c **** 
 340:../generate/compiler/init/syscalls.c ****     i = _swiwrite(fh, (char_t *)buffer, (uint16_t)n);
 364              		.loc 1 340 0
 365 0004 7220FFE6 		uxth	r2, r2
 366              	.LVL29:
 367 0008 FEFFFFEB 		bl	_swiwrite
 368              	.LVL30:
 341:../generate/compiler/init/syscalls.c **** 
 342:../generate/compiler/init/syscalls.c ****     return (i);
 343:../generate/compiler/init/syscalls.c **** }
 369              		.loc 1 343 0
 370 000c 1080BDE8 		pop	{r4, pc}
 371              		.cfi_endproc
 372              	.LFE15:
 374              		.section	.text._sbrk,"ax",%progbits
 375              		.align	2
 376              		.global	_sbrk
 377              		.syntax unified
 378              		.arm
 379              		.fpu neon
 381              	_sbrk:
 382              	.LFB6:
 166:../generate/compiler/init/syscalls.c ****   extern char   end __asm ("__heap_start");         /* Defined by the linker.  */
 383              		.loc 1 166 0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 0
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              	.LVL31:
 388 0000 0030A0E1 		mov	r3, r0
 172:../generate/compiler/init/syscalls.c ****     heap_end = & end;
 389              		.loc 1 172 0
 390 0004 002000E3 		movw	r2, #:lower16:.LANCHOR2
 391 0008 002040E3 		movt	r2, #:upper16:.LANCHOR2
 392 000c 002092E5 		ldr	r2, [r2]
 393 0010 000052E3 		cmp	r2, #0
 394 0014 0B00000A 		beq	.L35
 395              	.L28:
 175:../generate/compiler/init/syscalls.c **** 
 396              		.loc 1 175 0
 397 0018 002000E3 		movw	r2, #:lower16:.LANCHOR2
 398 001c 002040E3 		movt	r2, #:upper16:.LANCHOR2
 399 0020 000092E5 		ldr	r0, [r2]
 400              	.LVL32:
 177:../generate/compiler/init/syscalls.c ****     {
 401              		.loc 1 177 0
 402 0024 033080E0 		add	r3, r0, r3
 403              	.LVL33:
 404 0028 002000E3 		movw	r2, #:lower16:__heap_end
 405 002c 002040E3 		movt	r2, #:upper16:__heap_end
 406 0030 020053E1 		cmp	r3, r2
 407 0034 0900008A 		bhi	.L36
 196:../generate/compiler/init/syscalls.c **** 
 408              		.loc 1 196 0
 409 0038 002000E3 		movw	r2, #:lower16:.LANCHOR2
 410 003c 002040E3 		movt	r2, #:upper16:.LANCHOR2
 411 0040 003082E5 		str	r3, [r2]
 198:../generate/compiler/init/syscalls.c **** }
 412              		.loc 1 198 0
 413 0044 1EFF2FE1 		bx	lr
 414              	.LVL34:
 415              	.L35:
 173:../generate/compiler/init/syscalls.c **** 
 416              		.loc 1 173 0
 417 0048 002000E3 		movw	r2, #:lower16:.LANCHOR2
 418 004c 002040E3 		movt	r2, #:upper16:.LANCHOR2
 419 0050 001000E3 		movw	r1, #:lower16:__heap_start
 420 0054 001040E3 		movt	r1, #:upper16:__heap_start
 421 0058 001082E5 		str	r1, [r2]
 422 005c EDFFFFEA 		b	.L28
 423              	.LVL35:
 424              	.L36:
 166:../generate/compiler/init/syscalls.c ****   extern char   end __asm ("__heap_start");         /* Defined by the linker.  */
 425              		.loc 1 166 0
 426 0060 10402DE9 		push	{r4, lr}
 427              		.cfi_def_cfa_offset 8
 428              		.cfi_offset 4, -8
 429              		.cfi_offset 14, -4
 182:../generate/compiler/init/syscalls.c **** 
 430              		.loc 1 182 0
 431 0064 2020A0E3 		mov	r2, #32
 432 0068 001000E3 		movw	r1, #:lower16:.LC3
 433 006c 001040E3 		movt	r1, #:upper16:.LC3
 434 0070 0100A0E3 		mov	r0, #1
 435              	.LVL36:
 436 0074 FEFFFFEB 		bl	_write
 437              	.LVL37:
 191:../generate/compiler/init/syscalls.c ****       return (caddr_t) -1;
 438              		.loc 1 191 0
 439 0078 003000E3 		movw	r3, #:lower16:errno
 440 007c 003040E3 		movt	r3, #:upper16:errno
 441 0080 0C20A0E3 		mov	r2, #12
 442 0084 002083E5 		str	r2, [r3]
 192:../generate/compiler/init/syscalls.c **** #endif
 443              		.loc 1 192 0
 444 0088 0000E0E3 		mvn	r0, #0
 445 008c 1080BDE8 		pop	{r4, pc}
 446              		.cfi_endproc
 447              	.LFE6:
 449              		.section	.text._stat,"ax",%progbits
 450              		.align	2
 451              		.global	_stat
 452              		.syntax unified
 453              		.arm
 454              		.fpu neon
 456              	_stat:
 457              	.LFB16:
 344:../generate/compiler/init/syscalls.c **** 
 345:../generate/compiler/init/syscalls.c **** 
 346:../generate/compiler/init/syscalls.c **** int _stat (const char *fname, struct stat *st)
 347:../generate/compiler/init/syscalls.c **** {
 458              		.loc 1 347 0
 459              		.cfi_startproc
 460              		@ Volatile: function does not return.
 461              		@ args = 0, pretend = 0, frame = 0
 462              		@ frame_needed = 0, uses_anonymous_args = 0
 463              		@ link register save eliminated.
 464              	.LVL38:
 465              	.L38:
 466 0000 FEFFFFEA 		b	.L38
 467              		.cfi_endproc
 468              	.LFE16:
 470              		.section	.text._swiopen,"ax",%progbits
 471              		.align	2
 472              		.global	_swiopen
 473              		.syntax unified
 474              		.arm
 475              		.fpu neon
 477              	_swiopen:
 478              	.LFB9:
 224:../generate/compiler/init/syscalls.c ****   int aflags = 0, fh;
 479              		.loc 1 224 0
 480              		.cfi_startproc
 481              		@ args = 0, pretend = 0, frame = 64
 482              		@ frame_needed = 0, uses_anonymous_args = 0
 483              	.LVL39:
 224:../generate/compiler/init/syscalls.c ****   int aflags = 0, fh;
 484              		.loc 1 224 0
 485 0000 04E02DE5 		str	lr, [sp, #-4]!
 486              		.cfi_def_cfa_offset 4
 487              		.cfi_offset 14, -4
 488 0004 44D04DE2 		sub	sp, sp, #68
 489              		.cfi_def_cfa_offset 72
 490              	.LVL40:
 229:../generate/compiler/init/syscalls.c ****     {
 491              		.loc 1 229 0
 492 0008 0A3C01E2 		and	r3, r1, #2560
 228:../generate/compiler/init/syscalls.c ****       && (flags & O_EXCL))
 493              		.loc 1 228 0
 494 000c 0A0C53E3 		cmp	r3, #2560
 495 0010 1300000A 		beq	.L51
 243:../generate/compiler/init/syscalls.c ****     aflags |= 1;
 496              		.loc 1 243 0
 497 0014 013811E2 		ands	r3, r1, #65536
 244:../generate/compiler/init/syscalls.c **** #endif
 498              		.loc 1 244 0
 499 0018 0130A013 		movne	r3, #1
 500              	.L41:
 501              	.LVL41:
 248:../generate/compiler/init/syscalls.c ****     aflags |= O_RDWR;
 502              		.loc 1 248 0
 503 001c 020011E3 		tst	r1, #2
 249:../generate/compiler/init/syscalls.c ****   }
 504              		.loc 1 249 0
 505 0020 02308313 		orrne	r3, r3, #2
 506              	.LVL42:
 507              	.L42:
 251:../generate/compiler/init/syscalls.c ****     aflags |= O_WRONLY;
 508              		.loc 1 251 0
 509 0024 012011E2 		ands	r2, r1, #1
 252:../generate/compiler/init/syscalls.c ****   }
 510              		.loc 1 252 0
 511 0028 01308313 		orrne	r3, r3, #1
 512              	.LVL43:
 513              	.L43:
 254:../generate/compiler/init/syscalls.c ****     aflags |= O_CREAT;
 514              		.loc 1 254 0
 515 002c 020C11E3 		tst	r1, #512
 255:../generate/compiler/init/syscalls.c ****   }
 516              		.loc 1 255 0
 517 0030 023C8313 		orrne	r3, r3, #512
 518              	.LVL44:
 519              	.L44:
 257:../generate/compiler/init/syscalls.c ****     aflags |= O_TRUNC;
 520              		.loc 1 257 0
 521 0034 010B11E3 		tst	r1, #1024
 258:../generate/compiler/init/syscalls.c ****   }
 522              		.loc 1 258 0
 523 0038 013B8313 		orrne	r3, r3, #1024
 524              	.LVL45:
 525              	.L45:
 260:../generate/compiler/init/syscalls.c ****     aflags |= O_WRONLY;
 526              		.loc 1 260 0
 527 003c 000052E3 		cmp	r2, #0
 261:../generate/compiler/init/syscalls.c ****   }
 528              		.loc 1 261 0
 529 0040 01308313 		orrne	r3, r3, #1
 530              	.LVL46:
 531              	.L46:
 263:../generate/compiler/init/syscalls.c ****     aflags |= O_APPEND;
 532              		.loc 1 263 0
 533 0044 080011E3 		tst	r1, #8
 264:../generate/compiler/init/syscalls.c ****   }
 534              		.loc 1 264 0
 535 0048 08308313 		orrne	r3, r3, #8
 536              	.LVL47:
 537              	.L47:
 267:../generate/compiler/init/syscalls.c **** 
 538              		.loc 1 267 0
 539 004c 0310A0E1 		mov	r1, r3
 540              	.LVL48:
 541 0050 FEFFFFEB 		bl	low_open
 542              	.LVL49:
 270:../generate/compiler/init/syscalls.c ****     {
 543              		.loc 1 270 0
 544 0054 000050E3 		cmp	r0, #0
 545 0058 030000BA 		blt	.L52
 546              	.LVL50:
 547              	.L39:
 276:../generate/compiler/init/syscalls.c **** 
 548              		.loc 1 276 0
 549 005c 44D08DE2 		add	sp, sp, #68
 550              		.cfi_remember_state
 551              		.cfi_def_cfa_offset 4
 552              		@ sp needed
 553 0060 04F09DE4 		ldr	pc, [sp], #4
 554              	.LVL51:
 555              	.L51:
 556              		.cfi_restore_state
 557              	.LBB2:
 233:../generate/compiler/init/syscalls.c ****       if (res != -1)
 558              		.loc 1 233 0
 559 0064 04108DE2 		add	r1, sp, #4
 560              	.LVL52:
 561 0068 FEFFFFEB 		bl	_stat
 562              	.LVL53:
 563              	.L52:
 564              	.LBE2:
 274:../generate/compiler/init/syscalls.c ****     return (-1);
 565              		.loc 1 274 0
 566 006c 003000E3 		movw	r3, #:lower16:errno
 567 0070 003040E3 		movt	r3, #:upper16:errno
 568 0074 1120A0E3 		mov	r2, #17
 569 0078 002083E5 		str	r2, [r3]
 275:../generate/compiler/init/syscalls.c **** }
 570              		.loc 1 275 0
 571 007c 0000E0E3 		mvn	r0, #0
 572              	.LVL54:
 573 0080 F5FFFFEA 		b	.L39
 574              		.cfi_endproc
 575              	.LFE9:
 577              		.section	.text._open,"ax",%progbits
 578              		.align	2
 579              		.global	_open
 580              		.syntax unified
 581              		.arm
 582              		.fpu neon
 584              	_open:
 585              	.LFB10:
 280:../generate/compiler/init/syscalls.c ****   return wrap (_swiopen (path, flags));
 586              		.loc 1 280 0
 587              		.cfi_startproc
 588              		@ args = 4, pretend = 12, frame = 0
 589              		@ frame_needed = 0, uses_anonymous_args = 1
 590              	.LVL55:
 591 0000 0E002DE9 		push	{r1, r2, r3}
 592              		.cfi_def_cfa_offset 12
 593              		.cfi_offset 1, -12
 594              		.cfi_offset 2, -8
 595              		.cfi_offset 3, -4
 596 0004 04E02DE5 		str	lr, [sp, #-4]!
 597              		.cfi_def_cfa_offset 16
 598              		.cfi_offset 14, -16
 281:../generate/compiler/init/syscalls.c **** }
 599              		.loc 1 281 0
 600 0008 04109DE5 		ldr	r1, [sp, #4]
 601 000c FEFFFFEB 		bl	_swiopen
 602              	.LVL56:
 603 0010 FEFFFFEB 		bl	wrap
 604              	.LVL57:
 282:../generate/compiler/init/syscalls.c **** 
 605              		.loc 1 282 0
 606 0014 04E09DE4 		ldr	lr, [sp], #4
 607              		.cfi_restore 14
 608              		.cfi_def_cfa_offset 12
 609 0018 0CD08DE2 		add	sp, sp, #12
 610              		.cfi_restore 3
 611              		.cfi_restore 2
 612              		.cfi_restore 1
 613              		.cfi_def_cfa_offset 0
 614 001c 1EFF2FE1 		bx	lr
 615              		.cfi_endproc
 616              	.LFE10:
 618              		.section	.text._fstat,"ax",%progbits
 619              		.align	2
 620              		.global	_fstat
 621              		.syntax unified
 622              		.arm
 623              		.fpu neon
 625              	_fstat:
 626              	.LFB17:
 348:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(fname);
 349:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(st);
 350:../generate/compiler/init/syscalls.c **** 
 351:../generate/compiler/init/syscalls.c ****   while(1);
 352:../generate/compiler/init/syscalls.c **** }
 353:../generate/compiler/init/syscalls.c **** 
 354:../generate/compiler/init/syscalls.c **** /********************************************************/
 355:../generate/compiler/init/syscalls.c **** int _fstat (int fd, struct stat * st)
 356:../generate/compiler/init/syscalls.c **** {
 627              		.loc 1 356 0
 628              		.cfi_startproc
 629              		@ args = 0, pretend = 0, frame = 0
 630              		@ frame_needed = 0, uses_anonymous_args = 0
 631              		@ link register save eliminated.
 632              	.LVL58:
 357:../generate/compiler/init/syscalls.c **** 	UNUSED_PARAM(fd);
 358:../generate/compiler/init/syscalls.c **** 
 359:../generate/compiler/init/syscalls.c ****     /* Always return as charactor device. */
 360:../generate/compiler/init/syscalls.c ****     st->st_mode = S_IFCHR;
 633              		.loc 1 360 0
 634 0000 023AA0E3 		mov	r3, #8192
 635 0004 043081E5 		str	r3, [r1, #4]
 361:../generate/compiler/init/syscalls.c ****     return  0;
 362:../generate/compiler/init/syscalls.c **** }
 636              		.loc 1 362 0
 637 0008 0000A0E3 		mov	r0, #0
 638              	.LVL59:
 639 000c 1EFF2FE1 		bx	lr
 640              		.cfi_endproc
 641              	.LFE17:
 643              		.section	.text._isatty,"ax",%progbits
 644              		.align	2
 645              		.global	_isatty
 646              		.syntax unified
 647              		.arm
 648              		.fpu neon
 650              	_isatty:
 651              	.LFB18:
 363:../generate/compiler/init/syscalls.c **** 
 364:../generate/compiler/init/syscalls.c **** /********************************************************/
 365:../generate/compiler/init/syscalls.c **** int _isatty(int fd)
 366:../generate/compiler/init/syscalls.c **** {
 652              		.loc 1 366 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 0
 655              		@ frame_needed = 0, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657              	.LVL60:
 367:../generate/compiler/init/syscalls.c ****     if ((fd == STDOUT_FILENO) || (fd == STDERR_FILENO))
 658              		.loc 1 367 0
 659 0000 010040E2 		sub	r0, r0, #1
 660              	.LVL61:
 661 0004 010050E3 		cmp	r0, #1
 662 0008 0100008A 		bhi	.L59
 368:../generate/compiler/init/syscalls.c ****     {
 369:../generate/compiler/init/syscalls.c ****         return  1;
 663              		.loc 1 369 0
 664 000c 0100A0E3 		mov	r0, #1
 665              	.LVL62:
 370:../generate/compiler/init/syscalls.c ****     }
 371:../generate/compiler/init/syscalls.c ****     else
 372:../generate/compiler/init/syscalls.c ****     {
 373:../generate/compiler/init/syscalls.c ****         errno = EBADF;
 374:../generate/compiler/init/syscalls.c ****         return  -1;
 375:../generate/compiler/init/syscalls.c ****     }
 376:../generate/compiler/init/syscalls.c **** }
 666              		.loc 1 376 0
 667 0010 1EFF2FE1 		bx	lr
 668              	.L59:
 373:../generate/compiler/init/syscalls.c ****         return  -1;
 669              		.loc 1 373 0
 670 0014 003000E3 		movw	r3, #:lower16:errno
 671 0018 003040E3 		movt	r3, #:upper16:errno
 672 001c 0920A0E3 		mov	r2, #9
 673 0020 002083E5 		str	r2, [r3]
 374:../generate/compiler/init/syscalls.c ****     }
 674              		.loc 1 374 0
 675 0024 0000E0E3 		mvn	r0, #0
 676 0028 1EFF2FE1 		bx	lr
 677              		.cfi_endproc
 678              	.LFE18:
 680              		.section	.bss.heap_end.8084,"aw",%nobits
 681              		.align	2
 682              		.set	.LANCHOR2,. + 0
 685              	heap_end.8084:
 686 0000 00000000 		.space	4
 687              		.section	.bss.monitor_stderr,"aw",%nobits
 688              		.align	2
 689              		.set	.LANCHOR1,. + 0
 692              	monitor_stderr:
 693 0000 00000000 		.space	4
 694              		.section	.bss.monitor_stdout,"aw",%nobits
 695              		.align	2
 696              		.set	.LANCHOR0,. + 0
 699              	monitor_stdout:
 700 0000 00000000 		.space	4
 701              		.section	.rodata._sbrk.str1.4,"aMS",%progbits,1
 702              		.align	2
 703              	.LC3:
 704 0000 5F736272 		.ascii	"_sbrk: Heap and stack collision\012\000"
 704      6B3A2048 
 704      65617020 
 704      616E6420 
 704      73746163 
 705              		.section	.rodata.initialise_monitor_handles.str1.4,"aMS",%progbits,1
 706              		.align	2
 707              	.LC0:
 708 0000 5C5C2E5C 		.ascii	"\\\\.\\stdin\000"
 708      73746469 
 708      6E00
 709 000a 0000     		.space	2
 710              	.LC1:
 711 000c 5C5C2E5C 		.ascii	"\\\\.\\stdout\000"
 711      7374646F 
 711      757400
 712 0017 00       		.space	1
 713              	.LC2:
 714 0018 5C5C2E5C 		.ascii	"\\\\.\\stderr\000"
 714      73746465 
 714      727200
 715              		.text
 716              	.Letext0:
 717              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 718              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 719              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 720              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\lib\\gcc\\arm-none-eab
 721              		.file 6 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 722              		.file 7 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 723              		.file 8 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 724              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 725              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 726              		.file 11 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 727              		.file 12 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 728              		.file 13 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 729              		.file 14 "C:/Users/tle/e2_studio/workspace/rza2m_cam_and_disp_sample_freertos_gcc/generate/system/
 730              		.file 15 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 731              		.file 16 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 732              		.file 17 "C:/Users/tle/e2_studio/workspace/rza2m_cam_and_disp_sample_freertos_gcc/generate/system/
DEFINED SYMBOLS
                            *ABS*:00000000 syscalls.c
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:17     .text.get_errno:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:22     .text.get_errno:00000000 get_errno
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:37     .text.error:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:42     .text.error:00000000 error
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:67     .text.wrap:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:72     .text.wrap:00000000 wrap
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:96     .text.initialise_monitor_handles:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:102    .text.initialise_monitor_handles:00000000 initialise_monitor_handles
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:707    .rodata.initialise_monitor_handles.str1.4:00000000 .LC0
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:710    .rodata.initialise_monitor_handles.str1.4:0000000c .LC1
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:696    .bss.monitor_stdout:00000000 .LANCHOR0
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:713    .rodata.initialise_monitor_handles.str1.4:00000018 .LC2
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:689    .bss.monitor_stderr:00000000 .LANCHOR1
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:155    .text._getpid:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:161    .text._getpid:00000000 _getpid
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:177    .text._lseek:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:183    .text._lseek:00000000 _lseek
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:199    .text._swiread:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:205    .text._swiread:00000000 _swiread
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:228    .text._swiclose:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:234    .text._swiclose:00000000 _swiclose
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:254    .text._close:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:260    .text._close:00000000 _close
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:289    .text._read:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:295    .text._read:00000000 _read
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:318    .text._swiwrite:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:324    .text._swiwrite:00000000 _swiwrite
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:347    .text._write:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:353    .text._write:00000000 _write
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:375    .text._sbrk:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:381    .text._sbrk:00000000 _sbrk
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:682    .bss.heap_end.8084:00000000 .LANCHOR2
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:703    .rodata._sbrk.str1.4:00000000 .LC3
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:450    .text._stat:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:456    .text._stat:00000000 _stat
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:471    .text._swiopen:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:477    .text._swiopen:00000000 _swiopen
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:578    .text._open:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:584    .text._open:00000000 _open
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:619    .text._fstat:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:625    .text._fstat:00000000 _fstat
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:644    .text._isatty:00000000 $a
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:650    .text._isatty:00000000 _isatty
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:681    .bss.heap_end.8084:00000000 $d
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:685    .bss.heap_end.8084:00000000 heap_end.8084
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:688    .bss.monitor_stderr:00000000 $d
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:692    .bss.monitor_stderr:00000000 monitor_stderr
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:695    .bss.monitor_stdout:00000000 $d
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:699    .bss.monitor_stdout:00000000 monitor_stdout
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:702    .rodata._sbrk.str1.4:00000000 $d
C:\Users\tle\AppData\Local\Temp\cc2jYjw5.s:706    .rodata.initialise_monitor_handles.str1.4:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.14fc17be114e5a2cba0959c511ea2aaf
                           .group:00000000 wm4._newlib_version.h.4.3572908597b70d672d181fc7fc501c19
                           .group:00000000 wm4.newlib.h.21.59901f4bf241ab46c63694665baa7297
                           .group:00000000 wm4.features.h.22.5cdadbb3efe495d1c9e38350b8c376c7
                           .group:00000000 wm4.config.h.219.65a553ab5bef5482f0d7880b0d33015e
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4.stddef.h.39.a38874c8f8a57e66301090908ec2a69f
                           .group:00000000 wm4.cdefs.h.47.e658329a094974ebad41b40c60502de7
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:00000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:00000000 wm4._types.h.183.c226d164ceca1f2ecb9ae9360c54a098
                           .group:00000000 wm4.reent.h.17.23b059516345f8f5abfa01ddc379570f
                           .group:00000000 wm4.time.h.14.849270cc7997ccc4e05edd146e568a9f
                           .group:00000000 wm4.stddef.h.161.19e15733342b50ead2919490b095303e
                           .group:00000000 wm4.time.h.2.4581ce0ffb6627cfc02162c94bf846c9
                           .group:00000000 wm4.time.h.25.0e6a0fdbc9955f5707ed54246ed2e089
                           .group:00000000 wm4.types.h.40.e8c16e7ec36ba55f133d0616070e25fc
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4._endian.h.31.65a10590763c3dde1ac4a7f66d7d4891
                           .group:00000000 wm4.endian.h.9.49f3a4695c1b61e8a0808de3c4a106cb
                           .group:00000000 wm4._timeval.h.30.0e8bfd94e85db17dda3286ee81496fe6
                           .group:00000000 wm4.timespec.h.41.d855182eb0e690443ab8651bcedca6e1
                           .group:00000000 wm4.select.h.30.bbece7fa40993a78092dcc5805132560
                           .group:00000000 wm4.types.h.69.ed3eae3cf73030a737515151ebcab7a1
                           .group:00000000 wm4.time.h.162.d096f2f5887c52e271c4dc33d795dc64
                           .group:00000000 wm4.stat.h.71.d65ac61ff88c651e198008cfb38bda9c
                           .group:00000000 wm4.errno.h.2.ba016d646105af6cad23be83630b6a3f
                           .group:00000000 wm4.errno.h.9.1ecd7b1049497a0ab61da0f6cbd4b0c6
                           .group:00000000 wm4._intsup.h.10.cce27fed8484c08a33f522034c30d2b5
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.math.h.13.adb102f7bd7860b1f241e149d6914a1e
                           .group:00000000 wm4.r_typedefs.h.38.e90d9de5300d9ae020e5db8c5af88b3e
                           .group:00000000 wm4.stdio.h.27.3fc80220048df77954e38daec3bb9670
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.stdio.h.47.1f5845210bb9053bbca9ed76fc4018da
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.81.8188691c2279eac7a223caa50f6694b9
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.d4493cd3736e51e9d56335045f26df45
                           .group:00000000 wm4.reent.h.91.b3ea049ebc5486622b61409b78486f84
                           .group:00000000 wm4._default_fcntl.h.6.b13d56891b95175b639f824a0fd1ed77
                           .group:00000000 wm4.fcntl.h.9.9336f33d7f5028f694c75e6e224e0cf7
                           .group:00000000 wm4.driver.h.34.180df73e0731406f5e50150641059ede
                           .group:00000000 wm4.r_devlink_wrapper.h.70.7c1584c2697f3b1858aea58c7b3e40d4
                           .group:00000000 wm4.unistd.h.2.39165d5b7784d1815ef4b0c4be6df560
                           .group:00000000 wm4.unistd.h.156.614f0202926a9fae83688cfc56e25f59
                           .group:00000000 wm4.swi.h.26.8ef6964e359001cec347a6f29578eb74
                           .group:00000000 wm4.r_startup_config.h.28.5c666c62fea732748f6d5e42947a9287

UNDEFINED SYMBOLS
errno
low_open
low_read
low_close
low_write
__heap_end
__heap_start
